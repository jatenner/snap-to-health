import { OpenAI } from "openai";
import { NutritionData, NutritionixFood, NutrientInfo } from './nutritionixApi';
import { GPT_MODEL } from './constants';

// Extend the NutritionData interface to include source information
export interface ExtendedNutritionData extends NutritionData {
  source: 'gpt' | 'nutritionix' | 'gpt_fallback_empty' | 'gpt_error';
}

/**
 * Generate nutrition data using GPT when Nutritionix API fails
 * Includes better timeout handling and error logging
 * Always returns a valid object with description and nutrients fields
 * @param foodDescription Description of food to analyze
 * @param requestId Request identifier for tracking
 * @returns Nutritional data generated by GPT, always returns a valid object
 */
export async function callGptNutritionFallback(
  foodDescription: string,
  requestId: string
): Promise<NutritionData> {
  console.time(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
  console.log(`ü§ñ [${requestId}] Calling GPT nutrition fallback for: ${foodDescription}`);
  
  // Ensure we have a valid food description
  const safeDescription = foodDescription || "Unknown meal";
  
  // Define default nutrients to use in case of error - never return empty array
  const defaultNutrients: NutrientInfo[] = [
    { name: 'calories', value: 500, unit: 'kcal', isHighlight: true },
    { name: 'protein', value: 15, unit: 'g', isHighlight: true },
    { name: 'carbs', value: 40, unit: 'g', isHighlight: true },
    { name: 'fat', value: 20, unit: 'g', isHighlight: true },
    { name: 'fiber', value: 3, unit: 'g', isHighlight: false },
    { name: 'sugar', value: 10, unit: 'g', isHighlight: false },
    { name: 'sodium', value: 500, unit: 'mg', isHighlight: false },
  ];

  // Create a mock NutritionixFood object that matches the required interface
  const mockFood: NutritionixFood = {
    food_name: safeDescription,
    serving_qty: 1,
    serving_unit: 'serving',
    serving_weight_grams: 100,
    nf_calories: 500,
    nf_total_fat: 20,
    nf_saturated_fat: 5,
    nf_cholesterol: 50,
    nf_sodium: 500,
    nf_total_carbohydrate: 40,
    nf_dietary_fiber: 3,
    nf_sugars: 10,
    nf_protein: 15,
    nf_potassium: 300,
    nf_p: 100,
    full_nutrients: [],
    photo: {
      thumb: '',
      highres: '',
      is_user_uploaded: false
    }
  };
  
  // Set timeout for OpenAI request (8 seconds)
  const timeoutMs = 8000;
  
  try {
    // Validate OpenAI API Key
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OpenAI API key is not configured');
    }
    
    // Initialize OpenAI client
    const openai = new OpenAI({
      apiKey: apiKey,
    });

    const timeoutPromise = new Promise<null>((_, reject) => {
      setTimeout(() => {
        reject(new Error('GPT nutrition request timed out'));
      }, timeoutMs);
    });

    // Setup the API request
    const apiPromise = openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a nutrition expert who extracts accurate nutrition information from food descriptions. Provide nutrition data in JSON format."
        },
        {
          role: "user",
          content: `Extract nutritional information for: ${safeDescription}. Return ONLY a JSON object with these fields: description (brief description of the food), calories (kcal), protein (g), carbs (g), fat (g), fiber (g), sugar (g), sodium (mg). Use numeric values only for nutrients.`
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.2,
    });

    // Race between the API call and timeout
    console.log(`‚è≥ [${requestId}] Waiting for GPT nutrition response (timeout: ${timeoutMs}ms)`);
    const startTime = Date.now();
    
    // @ts-ignore
    const response = await Promise.race([apiPromise, timeoutPromise]);
    
    const endTime = Date.now();
    console.log(`‚åõ [${requestId}] GPT nutrition response received in ${endTime - startTime}ms`);

    if (response) {
      // Parse response content
      try {
        // Always provide a fallback for empty or invalid responses
        const responseText = response.choices[0]?.message?.content || "{}";
        let nutritionData;
        
        try {
          nutritionData = JSON.parse(responseText);
        } catch (jsonError) {
          console.error(`‚ùå [${requestId}] Invalid JSON response from GPT:`, responseText);
          nutritionData = {};
        }
        
        // Extract description (fallback if not provided)
        const description = nutritionData.description || safeDescription || "Unknown meal";
        
        // Create a structured response format - always use fallbacks for each nutrient
        const nutrients: NutrientInfo[] = [
          { name: 'calories', value: nutritionData.calories || 500, unit: 'kcal', isHighlight: true },
          { name: 'protein', value: nutritionData.protein || 15, unit: 'g', isHighlight: true },
          { name: 'carbs', value: nutritionData.carbs || 40, unit: 'g', isHighlight: true },
          { name: 'fat', value: nutritionData.fat || 20, unit: 'g', isHighlight: true },
          { name: 'fiber', value: nutritionData.fiber || 3, unit: 'g', isHighlight: false },
          { name: 'sugar', value: nutritionData.sugar || 10, unit: 'g', isHighlight: false },
          { name: 'sodium', value: nutritionData.sodium || 500, unit: 'mg', isHighlight: false },
        ];

        // Check if we have valid nutrition data
        const hasValidNutritionData = 
          nutritionData.calories !== undefined || 
          nutritionData.protein !== undefined ||
          nutritionData.carbs !== undefined ||
          nutritionData.fat !== undefined;

        // Create a food item with the extracted nutrition data
        const food: NutritionixFood = {
          food_name: description,
          serving_qty: 1,
          serving_unit: 'serving',
          serving_weight_grams: 100,
          nf_calories: nutritionData.calories || 500,
          nf_total_fat: nutritionData.fat || 20,
          nf_saturated_fat: nutritionData.fat ? nutritionData.fat / 4 : 5,
          nf_cholesterol: 50,
          nf_sodium: nutritionData.sodium || 500,
          nf_total_carbohydrate: nutritionData.carbs || 40,
          nf_dietary_fiber: nutritionData.fiber || 3,
          nf_sugars: nutritionData.sugar || 10,
          nf_protein: nutritionData.protein || 15,
          nf_potassium: 300,
          nf_p: 100,
          full_nutrients: [],
          photo: {
            thumb: '',
            highres: '',
            is_user_uploaded: false
          }
        };

        // Determine source based on completeness of response
        const source = hasValidNutritionData ? 'gpt' : 'gpt_fallback_empty';
        
        if (!hasValidNutritionData) {
          console.warn(`‚ö†Ô∏è [${requestId}] GPT returned incomplete nutrition data, using fallback values`);
        } else {
          console.log(`‚úÖ [${requestId}] Successfully generated nutrition data with GPT`);
        }
        
        console.timeEnd(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
        
        return {
          nutrients,
          foods: [food],
          raw: {
            description,
            model: response.model,
            promptTokens: response.usage?.prompt_tokens,
            completionTokens: response.usage?.completion_tokens,
            response: responseText,
            source,
            error: hasValidNutritionData ? null : 'Incomplete nutrition data',
            fallback: !hasValidNutritionData
          }
        };
      } catch (parseError: any) {
        console.error(`‚ùå [${requestId}] Failed to parse GPT nutrition response:`, parseError);
        console.error(`‚ùå [${requestId}] Raw response:`, response.choices[0]?.message?.content);
      }
    }
  } catch (error: any) {
    const errorMessage = error.message || 'Unknown error';
    console.error(`‚ùå [${requestId}] Error in GPT nutrition fallback:`, errorMessage);
    
    if (errorMessage.includes('timed out')) {
      console.error(`‚è±Ô∏è [${requestId}] GPT nutrition request timed out after ${timeoutMs}ms`);
    }
  }
  
  console.log(`‚ö†Ô∏è [${requestId}] Using default nutrition values due to GPT fallback error`);
  console.timeEnd(`‚è±Ô∏è [${requestId}] GPT nutrition fallback`);
  
  // Create a descriptive fallback message based on the input
  const fallbackDescription = 
    safeDescription === "Unknown meal" 
      ? "Unable to analyze this meal" 
      : `This appears to be ${safeDescription}. Unable to provide detailed analysis.`;
  
  // Return default values in case of any error - ensure we always have a description and nutrients
  return {
    nutrients: defaultNutrients,
    foods: [mockFood],
    raw: {
      description: fallbackDescription,
      source: 'gpt_error',
      error: 'Error generating nutrition data',
      fallback: true
    }
  };
} 